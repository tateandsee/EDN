import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { db } from '@/lib/db'
import { GamificationProgressService } from '@/lib/gamification-progress'
import { generateTitleFromPrompt, extractTitleFromMarketplaceItem } from '@/lib/marketplace-title-extractor'

// Helper function to check if user is admin or if in development mode
async function shouldBypassRestrictions(): Promise<boolean> {
  // Check if in development mode
  if (process.env.NODE_ENV === 'development') {
    return true
  }

  // Check if user is admin
  try {
    const session = await getServerSession(authOptions)
    if (session?.user?.id) {
      const user = await db.user.findUnique({
        where: { id: session.user.id },
        select: { role: true }
      })
      return user?.role === 'ADMIN'
    }
  } catch (error) {
    console.error('Error checking user role:', error)
  }

  return false
}

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const category = searchParams.get('category')
    const type = searchParams.get('type')
    const minPrice = searchParams.get('minPrice')
    const maxPrice = searchParams.get('maxPrice')
    const search = searchParams.get('search')
    const ethnicity = searchParams.get('ethnicity')
    const hairColor = searchParams.get('hairColor')
    const bodyType = searchParams.get('bodyType')
    const attire = searchParams.get('attire')
    const page = parseInt(searchParams.get('page') || '1')
    const limit = parseInt(searchParams.get('limit') || '12')

    const where: any = {
      status: 'ACTIVE' // Only show active items by default
    }

    // Handle SFW/NSFW filtering
    if (category === 'SFW') {
      where.isNsfw = false
    } else if (category === 'NSFW') {
      where.isNsfw = true
    } else if (category && category !== 'all' && category !== 'ETHNICITY' && category !== 'HAIR_COLOR' && category !== 'BODY_TYPE' && category !== 'ATTIRE') {
      where.category = category
    }

    // Handle sub-category filtering
    if (ethnicity && ethnicity !== 'all') {
      where.tags = {
        contains: ethnicity,
        mode: 'insensitive'
      }
    }

    if (hairColor && hairColor !== 'all') {
      where.tags = {
        contains: hairColor,
        mode: 'insensitive'
      }
    }

    if (bodyType && bodyType !== 'all') {
      where.tags = {
        contains: bodyType,
        mode: 'insensitive'
      }
    }

    if (attire && attire !== 'all') {
      // Filter by attire tags - look for exact attire tag match
      where.tags = {
        contains: `"${attire}"`
      }
    }

    if (type && type !== 'all') {
      where.type = type
    }

    if (minPrice || maxPrice) {
      where.price = {}
      if (minPrice) where.price.gte = parseFloat(minPrice)
      if (maxPrice) where.price.lte = parseFloat(maxPrice)
    }

    if (search) {
      where.OR = [
        { title: { contains: search, mode: 'insensitive' } },
        { description: { contains: search, mode: 'insensitive' } },
        { tags: { contains: search, mode: 'insensitive' } }
      ]
    }

    const skip = (page - 1) * limit

    const [items, total] = await Promise.all([
      db.marketplaceItem.findMany({
        where,
        include: {
          user: {
            select: {
              id: true,
              name: true,
              avatar: true,
              verified: true
            }
          },
          reviews: {
            select: {
              rating: true,
              comment: true,
              createdAt: true,
              user: {
                select: {
                  name: true,
                  avatar: true
                }
              }
            }
          },
          _count: {
            select: {
              reviews: true,
              orders: true
            }
          }
        },
        orderBy: {
          createdAt: 'desc'
        },
        skip,
        take: limit
      }),
      db.marketplaceItem.count({ where })
    ])

    // Process items to extract title information and parse tags
    const bypassRestrictions = await shouldBypassRestrictions()
    
    const processedItems = items.map(item => {
      const { displayTitle, isAutoGenerated } = extractTitleFromMarketplaceItem(item)
      const parsedTags = item.tags ? JSON.parse(item.tags) : []
      
      // Apply content restrictions (bypass for admin/dev mode)
      if (!bypassRestrictions) {
        const restrictedTags = ['animal', 'child', 'kid', 'baby', 'men', 'male', 'pain', 'death', 'violence', 'blood']
        const hasRestrictedContent = restrictedTags.some(tag => 
          parsedTags.some((itemTag: string) => 
            itemTag.toLowerCase().includes(tag.toLowerCase())
          )
        )
        
        // Check age range (18-40) and gender (women only for NSFW)
        let ageAppropriate = true
        let genderAppropriate = true
        
        if (item.isNsfw) {
          // For NSFW content, enforce stricter restrictions
          const ageTags = parsedTags.filter((tag: string) => 
            tag.includes('years') || tag.includes('age') || tag.includes('old')
          )
          
          // Check if age is within 18-40 range
          ageAppropriate = ageTags.every((tag: string) => {
            const ageMatch = tag.match(/(\d+)/)
            if (!ageMatch) return true
            const age = parseInt(ageMatch[1])
            return age >= 18 && age <= 40
          })
          
          // Check gender restriction (women only for NSFW)
          const genderTags = parsedTags.filter((tag: string) => 
            tag.toLowerCase().includes('woman') || 
            tag.toLowerCase().includes('female') ||
            tag.toLowerCase().includes('girl') ||
            tag.toLowerCase().includes('man') ||
            tag.toLowerCase().includes('male')
          )
          
          genderAppropriate = genderTags.every((tag: string) => 
            !tag.toLowerCase().includes('man') && !tag.toLowerCase().includes('male')
          )
        }
        
        // Filter out items that violate content restrictions
        if (hasRestrictedContent || !ageAppropriate || !genderAppropriate) {
          return null
        }
      }
      
      return {
        ...item,
        tags: parsedTags,
        displayTitle,
        isAutoGenerated
      }
    }).filter(item => item !== null) // Remove filtered items

    // Calculate pagination based on filtered items if restrictions are applied, otherwise use original count
    const displayTotal = bypassRestrictions ? total : processedItems.length
    const displayPages = Math.ceil(displayTotal / limit)

    return NextResponse.json({
      items: processedItems,
      pagination: {
        page,
        limit,
        total: displayTotal,
        pages: displayPages
      }
    })
  } catch (error) {
    console.error('Error fetching marketplace items:', error)
    return NextResponse.json(
      { error: 'Failed to fetch marketplace items' },
      { status: 500 }
    )
  }
}

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const userId = session.user.id
    const bypassRestrictions = await shouldBypassRestrictions()

    const formData = await request.formData()
    const title = formData.get('title') as string
    const description = formData.get('description') as string
    const type = formData.get('type') as string
    const category = formData.get('category') as string
    const price = formData.get('price') as string
    const thumbnail = formData.get('thumbnail') as string
    const tags = formData.get('tags') as string
    const isNsfw = formData.get('isNsfw') === 'true'
    
    // Prompt-related fields
    const positivePrompt = formData.get('positivePrompt') as string
    const negativePrompt = formData.get('negativePrompt') as string
    const promptConfigStr = formData.get('promptConfig') as string
    let promptConfig = null
    
    if (promptConfigStr) {
      try {
        promptConfig = JSON.parse(promptConfigStr)
      } catch (error) {
        console.error('Error parsing prompt config:', error)
      }
    }
    
    // Handle file uploads
    const imageFiles = formData.getAll('images') as File[]
    const pdfFile = formData.get('pdfFile') as File | null

    if (!title || !type || !category || !price) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      )
    }

    // Parse and validate tags for content restrictions
    const parsedTags = tags ? tags.split(',').map(t => t.trim()) : []
    
    // Apply content restrictions (bypass for admin/dev mode)
    if (!bypassRestrictions) {
      const restrictedTags = ['animal', 'child', 'kid', 'baby', 'men', 'male', 'pain', 'death', 'violence', 'blood']
      const hasRestrictedContent = restrictedTags.some(tag => 
        parsedTags.some(itemTag => 
          itemTag.toLowerCase().includes(tag.toLowerCase())
        )
      )
      
      if (hasRestrictedContent) {
        return NextResponse.json(
          { error: 'Content violates restrictions. No animals, children, men, pain, death, or violent content allowed.' },
          { status: 400 }
        )
      }
      
      // Check age range (18-40) and gender (women only for NSFW)
      if (isNsfw) {
        // For NSFW content, enforce stricter restrictions
        const ageTags = parsedTags.filter(tag => 
          tag.includes('years') || tag.includes('age') || tag.includes('old')
        )
        
        // Check if age is within 18-40 range
        const ageAppropriate = ageTags.every(tag => {
          const ageMatch = tag.match(/(\d+)/)
          if (!ageMatch) return true
          const age = parseInt(ageMatch[1])
          return age >= 18 && age <= 40
        })
        
        if (!ageAppropriate) {
          return NextResponse.json(
            { error: 'NSFW content must feature subjects aged 18-40 only.' },
            { status: 400 }
          )
        }
        
        // Check gender restriction (women only for NSFW)
        const genderTags = parsedTags.filter(tag => 
          tag.toLowerCase().includes('woman') || 
          tag.toLowerCase().includes('female') ||
          tag.toLowerCase().includes('girl') ||
          tag.toLowerCase().includes('man') ||
          tag.toLowerCase().includes('male')
        )
        
        const genderAppropriate = genderTags.every(tag => 
          !tag.toLowerCase().includes('man') && !tag.toLowerCase().includes('male')
        )
        
        if (!genderAppropriate) {
          return NextResponse.json(
            { error: 'NSFW content must feature women only.' },
            { status: 400 }
          )
        }
      }
    }

    // Generate title from prompt data if not explicitly provided or if it's an auto-generated title
    let finalTitle = title
    let isAutoGenerated = false
    
    if (!title || title.startsWith('EDN ') || (positivePrompt || promptConfig)) {
      const extractedData = generateTitleFromPrompt(
        promptConfig,
        positivePrompt,
        negativePrompt
      )
      
      // Use the extracted title if no title is provided or if the current title looks auto-generated
      if (!title || title.startsWith('EDN ')) {
        finalTitle = extractedData.suggestedTitle
        isAutoGenerated = true
      }
      
      // Override category if extracted from prompts
      const extractedCategory = extractedData.category
      let finalCategory = category
      if (!category || category === 'auto') {
        finalCategory = extractedCategory
      }
    }

    // Process image files (in a real implementation, you would upload to cloud storage)
    const imageUrls: string[] = []
    if (imageFiles && imageFiles.length > 0) {
      for (const imageFile of imageFiles) {
        if (imageFile instanceof File) {
          // Convert to base64 for demo (in production, upload to cloud storage)
          const buffer = Buffer.from(await imageFile.arrayBuffer())
          const base64 = buffer.toString('base64')
          const mimeType = imageFile.type
          imageUrls.push(`data:${mimeType};base64,${base64}`)
        }
      }
    }

    // Process PDF file
    let pdfFileUrl = null
    let pdfFileName = null
    let pdfFileSize = null

    if (pdfFile && pdfFile instanceof File) {
      // Convert to base64 for demo (in production, upload to cloud storage)
      const buffer = Buffer.from(await pdfFile.arrayBuffer())
      const base64 = buffer.toString('base64')
      pdfFileUrl = `data:application/pdf;base64,${base64}`
      pdfFileName = pdfFile.name
      pdfFileSize = pdfFile.size
    }

    const item = await db.marketplaceItem.create({
      data: {
        title: finalTitle,
        description: description || undefined,
        type: type as any,
        category: finalCategory as any,
        price: parseFloat(price),
        currency: 'USD',
        thumbnail: thumbnail || undefined,
        images: imageUrls.length > 0 ? imageUrls : undefined,
        pdfFile: pdfFileUrl || undefined,
        pdfFileName: pdfFileName || undefined,
        pdfFileSize: pdfFileSize || undefined,
        tags: tags ? JSON.stringify(tags.split(',').map(t => t.trim())) : undefined,
        isNsfw,
        userId,
        // Store prompt-related fields
        promptConfig: promptConfig || undefined,
        positivePrompt: positivePrompt || undefined,
        negativePrompt: negativePrompt || undefined,
        fullPrompt: positivePrompt && negativePrompt ? `${positivePrompt} ${negativePrompt}` : positivePrompt || undefined
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            avatar: true,
            verified: true
          }
        }
      }
    })

    // Award points for creating marketplace item
    try {
      await GamificationProgressService.awardPoints(userId, 25, 'Created marketplace item')
    } catch (pointsError) {
      console.error('Error awarding points for marketplace item creation:', pointsError)
      // Don't fail the request if points awarding fails
    }

    return NextResponse.json({ 
      item, 
      metadata: {
        titleGenerated: isAutoGenerated,
        titleSource: isAutoGenerated ? 'prompts' : 'user_input'
      }
    }, { status: 201 })
  } catch (error) {
    console.error('Error creating marketplace item:', error)
    return NextResponse.json(
      { error: 'Failed to create marketplace item' },
      { status: 500 }
    )
  }
}