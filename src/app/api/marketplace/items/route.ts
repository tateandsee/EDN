import { NextRequest, NextResponse } from 'next/server'
import { db } from '@/lib/db'
import { GamificationProgressService } from '@/lib/gamification-progress'
import { generateTitleFromPrompt, extractTitleFromMarketplaceItem } from '@/lib/marketplace-title-extractor'

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const category = searchParams.get('category')
    const type = searchParams.get('type')
    const ethnicity = searchParams.get('ethnicity')
    const hairColor = searchParams.get('hairColor')
    const eyeColor = searchParams.get('eyeColor')
    const minPrice = searchParams.get('minPrice')
    const maxPrice = searchParams.get('maxPrice')
    const search = searchParams.get('search')
    const page = parseInt(searchParams.get('page') || '1')
    const limit = parseInt(searchParams.get('limit') || '12')

    const where: any = {}

    if (category && category !== 'all') {
      where.category = category
    }

    if (type && type !== 'all') {
      where.type = type
    }

    // Handle multiple tag filters
    const tagFilters = []
    if (ethnicity && ethnicity !== 'all') {
      tagFilters.push(ethnicity)
    }
    if (hairColor && hairColor !== 'all') {
      tagFilters.push(hairColor)
    }
    if (eyeColor && eyeColor !== 'all') {
      tagFilters.push(eyeColor)
    }

    if (tagFilters.length > 0) {
      // For JSON string tags, we need to search for each tag individually
      // and combine with OR conditions
      const tagConditions = tagFilters.map(tag => ({
        tags: {
          contains: `"${tag}"`,
          mode: 'insensitive'
        }
      }))
      
      if (tagConditions.length === 1) {
        where.tags = tagConditions[0].tags
      } else {
        where.OR = tagConditions
      }
    }

    if (minPrice || maxPrice) {
      where.price = {}
      if (minPrice) where.price.gte = parseFloat(minPrice)
      if (maxPrice) where.price.lte = parseFloat(maxPrice)
    }

    if (search) {
      const searchConditions = [
        { title: { contains: search, mode: 'insensitive' } },
        { description: { contains: search, mode: 'insensitive' } },
        { tags: { contains: search, mode: 'insensitive' } }
      ]
      
      if (where.OR) {
        where.OR = [...where.OR, ...searchConditions]
      } else {
        where.OR = searchConditions
      }
    }

    const skip = (page - 1) * limit

    const [items, total] = await Promise.all([
      db.marketplaceItem.findMany({
        where,
        include: {
          user: {
            select: {
              id: true,
              name: true,
              avatar: true,
              verified: true
            }
          },
          reviews: {
            select: {
              rating: true,
              comment: true,
              createdAt: true,
              user: {
                select: {
                  name: true,
                  avatar: true
                }
              }
            }
          },
          _count: {
            select: {
              reviews: true,
              orders: true
            }
          }
        },
        orderBy: {
          createdAt: 'desc'
        },
        skip,
        take: limit
      }),
      db.marketplaceItem.count({ where })
    ])

    // Process items to extract title information and parse tags
    const processedItems = items.map(item => {
      const { displayTitle, isAutoGenerated } = extractTitleFromMarketplaceItem(item)
      return {
        ...item,
        tags: item.tags ? JSON.parse(item.tags) : [],
        displayTitle,
        isAutoGenerated
      }
    })

    return NextResponse.json({
      items: processedItems,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit)
      }
    })
  } catch (error) {
    console.error('Error fetching marketplace items:', error)
    return NextResponse.json(
      { error: 'Failed to fetch marketplace items' },
      { status: 500 }
    )
  }
}

export async function POST(request: NextRequest) {
  try {
    const authHeader = request.headers.get('authorization')
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const token = authHeader.substring(7)
    // Here you would verify the token and get the user ID
    // For now, we'll use a placeholder
    const userId = 'user-id-placeholder'

    const formData = await request.formData()
    const title = formData.get('title') as string
    const description = formData.get('description') as string
    const type = formData.get('type') as string
    const category = formData.get('category') as string
    const price = formData.get('price') as string
    const thumbnail = formData.get('thumbnail') as string
    const tags = formData.get('tags') as string
    const isNsfw = formData.get('isNsfw') === 'true'
    
    // Prompt-related fields
    const positivePrompt = formData.get('positivePrompt') as string
    const negativePrompt = formData.get('negativePrompt') as string
    const promptConfigStr = formData.get('promptConfig') as string
    let promptConfig = null
    
    if (promptConfigStr) {
      try {
        promptConfig = JSON.parse(promptConfigStr)
      } catch (error) {
        console.error('Error parsing prompt config:', error)
      }
    }
    
    // Handle file uploads
    const imageFiles = formData.getAll('images') as File[]
    const pdfFile = formData.get('pdfFile') as File | null

    if (!title || !type || !category || !price) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      )
    }

    // Generate title from prompt data if not explicitly provided or if it's an auto-generated title
    let finalTitle = title
    let isAutoGenerated = false
    
    if (!title || title.startsWith('EDN ') || (positivePrompt || promptConfig)) {
      const extractedData = generateTitleFromPrompt(
        promptConfig,
        positivePrompt,
        negativePrompt
      )
      
      // Use the extracted title if no title is provided or if the current title looks auto-generated
      if (!title || title.startsWith('EDN ')) {
        finalTitle = extractedData.suggestedTitle
        isAutoGenerated = true
      }
      
      // Override category if extracted from prompts
      const extractedCategory = extractedData.category
      let finalCategory = category
      if (!category || category === 'auto') {
        finalCategory = extractedCategory
      }
    }

    // Process image files (in a real implementation, you would upload to cloud storage)
    const imageUrls: string[] = []
    if (imageFiles && imageFiles.length > 0) {
      for (const imageFile of imageFiles) {
        if (imageFile instanceof File) {
          // Convert to base64 for demo (in production, upload to cloud storage)
          const buffer = Buffer.from(await imageFile.arrayBuffer())
          const base64 = buffer.toString('base64')
          const mimeType = imageFile.type
          imageUrls.push(`data:${mimeType};base64,${base64}`)
        }
      }
    }

    // Process PDF file
    let pdfFileUrl = null
    let pdfFileName = null
    let pdfFileSize = null

    if (pdfFile && pdfFile instanceof File) {
      // Convert to base64 for demo (in production, upload to cloud storage)
      const buffer = Buffer.from(await pdfFile.arrayBuffer())
      const base64 = buffer.toString('base64')
      pdfFileUrl = `data:application/pdf;base64,${base64}`
      pdfFileName = pdfFile.name
      pdfFileSize = pdfFile.size
    }

    const item = await db.marketplaceItem.create({
      data: {
        title: finalTitle,
        description: description || undefined,
        type: type as any,
        category: finalCategory as any,
        price: parseFloat(price),
        currency: 'USD',
        thumbnail: thumbnail || undefined,
        images: imageUrls.length > 0 ? imageUrls : undefined,
        pdfFile: pdfFileUrl || undefined,
        pdfFileName: pdfFileName || undefined,
        pdfFileSize: pdfFileSize || undefined,
        tags: tags ? JSON.stringify(tags.split(',').map(t => t.trim())) : undefined,
        isNsfw,
        userId,
        // Store prompt-related fields
        promptConfig: promptConfig || undefined,
        positivePrompt: positivePrompt || undefined,
        negativePrompt: negativePrompt || undefined,
        fullPrompt: positivePrompt && negativePrompt ? `${positivePrompt} ${negativePrompt}` : positivePrompt || undefined
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            avatar: true,
            verified: true
          }
        }
      }
    })

    // Award points for creating marketplace item
    try {
      await GamificationProgressService.awardPoints(userId, 25, 'Created marketplace item')
    } catch (pointsError) {
      console.error('Error awarding points for marketplace item creation:', pointsError)
      // Don't fail the request if points awarding fails
    }

    return NextResponse.json({ 
      item, 
      metadata: {
        titleGenerated: isAutoGenerated,
        titleSource: isAutoGenerated ? 'prompts' : 'user_input'
      }
    }, { status: 201 })
  } catch (error) {
    console.error('Error creating marketplace item:', error)
    return NextResponse.json(
      { error: 'Failed to create marketplace item' },
      { status: 500 }
    )
  }
}